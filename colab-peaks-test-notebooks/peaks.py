# -*- coding: utf-8 -*-
"""peaks.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pRoOUJNHP6e-52ssKmID3W1HVzA92kbs

### keep in mind you need to get no of active cases(confirmed-recovered-deceased)
"""

from google.colab import drive
drive.mount('/content/gdrive')
root_path = '/content/gdrive/MyDrive/asgn1/'

import json 
import pandas as pd
import numpy as np
import requests
import datetime
import scipy.signal as signal
import matplotlib.pyplot as plt

# to open json file
# /content/gdrive/MyDrive/asgn1/neighbor-districts-modified.json
f=open('/content/gdrive/MyDrive/asgn1/neighbor-districts-modified.json')
 # this function basically stores json type files into python dictionary
dist_modified=json.load(f)

district_list_from_json=[]
for key in dist_modified:
    district_list_from_json.append(key)
district_list_from_json=np.array(district_list_from_json)
district_list_from_json.sort()

state_district_codes=[]
for i in range(len(district_list_from_json)):
    state_district_codes.append(district_list_from_json[i].split('/')[1])

# district names - sample entry: churu
district_names_from_json=[] 

# district ids - sample entry: Q1090006
district_ids_from_json=[]

#use split() function and specify the separator '/' . Remember default seperator is whitspace
for i in range(len(district_list_from_json)):
    district_names_from_json.append(district_list_from_json[i].split("/")[0])
    district_ids_from_json.append(district_list_from_json[i].split("/")[1])

district_ids_list={}
for i in range(len(district_names_from_json)):
    district_ids_list[district_names_from_json[i]]=district_names_from_json[i] + '/' + district_ids_from_json[i]

# dictionaries for mapping dates to time ids
# eg. for 2020-3-15, time_id_week is 1, time_id_month is 1, time_id_ is 1

time_id_week = {}
time_id_month = {}
time_id_overall = {}

date=datetime.date(2020,3,15)
day=1
even_list=[]
odd_list=[]
for i in range(200):
    if (i+1)%2==0:
        even_list.append(i+1)
    else:
        odd_list.append(i+1)
while True:
    # basically to cover overlapping weeks this part needs to be changed.
    # for now we are proceeding. but change week ids according above definition of 7-DMA
    list_week=[0,1,2,6]
    if date.weekday() in list_week:
        time_id_week[str(date)]=odd_list[int(np.ceil(day/7))-1]
    else:
        time_id_week[str(date)]=even_list[int(np.ceil(day/7))-1]
        
    if str(date)[0:4]=='2020':
        if int(str(date)[8:10]) <15:
            time_id_month[str(date)]=int(str(date)[5:7])-3
        else:
            time_id_month[str(date)]=int(str(date)[5:7])-2
    else:
        if int(str(date)[8:10]) <15:
            time_id_month[str(date)]=int(str(date)[5:7])+9
        else:
            time_id_month[str(date)]=int(str(date)[5:7])+10

    time_id_overall[str(date)]=1
    
    if date==datetime.date(2021,8,14):
        break
    day=day+1
    date=date+datetime.timedelta(days=1)

data_csv=pd.read_csv('/content/gdrive/MyDrive/asgn1/districts.csv')
data_csv=data_csv.drop('Tested',axis=1)
data_csv.isnull().sum()

data_csv=data_csv.sort_values(['District','Date'])
data_csv.reset_index(inplace=True,drop=True)
data_csv['District']=data_csv['District'].str.lower()

district_names_from_cases=[]
district_ids_from_cases=[]
district_uniques=np.array(np.unique(data_csv['District']))
for i in range(len(district_ids_list)):
    for j in range(len(district_uniques)):
        if district_uniques[j]==district_names_from_json[i]:
            district_ids_from_cases.append(district_ids_from_json[i])
            district_names_from_cases.append(district_uniques[j])
            break

data_csv['Active']=data_csv['Confirmed']-(data_csv['Deceased']+data_csv['Recovered'])

# Commented out IPython magic to ensure Python compatibility.
# %%time
# data_csv['Daily Cases']=np.nan
# for i in range(len(district_names_from_cases)):
#     foo_df = data_csv[data_csv['District']==district_names_from_cases[i]]
#     foo_cases = foo_df.iloc[0,3]
#     foo_df['Daily Cases']=foo_df['Active'].diff() # active ones
#     foo_df.iloc[0,-1]=foo_cases
#     data_csv.loc[data_csv['District']==district_names_from_cases[i],'Daily Cases']=foo_df['Daily Cases']

data_csv.isnull().sum()

data_csv.dropna(inplace=True)

data_csv.isnull().sum()

dates_in_raw=np.unique(data_csv['Date']).tolist()

# Commented out IPython magic to ensure Python compatibility.
# %%time
# data_csv['Week ID']=np.nan
# data_csv['Month ID']=np.nan
# for date in time_id_week:
#     if dates_in_raw.count(date)>0:
#         data_csv.loc[data_csv['Date']==date,'Week ID']=time_id_week[date]
#         data_csv.loc[data_csv['Date']==date,'Month ID']=time_id_month[date]

data_csv.isnull().sum()

data_csv.dropna(inplace=True)

data_csv.isnull().sum()

# Commented out IPython magic to ensure Python compatibility.
# %%time
# # run it on your own risk it is too it might take 2-3 hours(don't know exact) hahaha
# # will try to find another method that is fast enough
# # no of weeks
# # should take around 15 minutes
# no_of_weeks=list(time_id_week.values())[-1]
# districtid=[]
# weekid=[]
# cases=[]
# active=[]
# for i in range(len(district_names_from_cases)):
#     for j in range(no_of_weeks):
#         districtid.append(district_ids_from_cases[i])
#         weekid.append(j+1)
#         foo_df=data_csv[(data_csv['District']==district_names_from_cases[i]) & ((data_csv['Week ID']==j+1) | (data_csv['Week ID']==j+2))]
#         cases.append(foo_df['Daily Cases'].sum())
#         active.append(foo_df['Active'].sum())
#             
# week_df=pd.DataFrame({'districtid':districtid,'weekid':weekid,'cases':cases,'active':active})
# week_df.to_csv('cases-week.csv',index=False)

# Commented out IPython magic to ensure Python compatibility.
# %%time
# no_of_months=list(time_id_month.values())[-1]
# districtid=[]
# monthid=[]
# cases=[]
# active=[]
# for i in range(len(district_names_from_cases)): # if delhi etc are not there just 
#     for j in range(no_of_months):
#         districtid.append(district_ids_from_cases[i])
#         monthid.append(j+1)
#         foo_df=data_csv[(data_csv['District']==district_names_from_cases[i]) & (data_csv['Month ID']==j+1)]
#         cases.append(foo_df['Daily Cases'].sum())
#         active.append(foo_df['Active'].astype(int).sum())
# month_df=pd.DataFrame({'districtid':districtid,'monthid':monthid,'cases':cases,'active':active})
# month_df.to_csv('cases-month.csv',index=False)

"""### timseseries can be plotted"""

def choose_function(time_series,indices):
    indices=indices.tolist()
    foo_list=time_series[indices]
    ind1=indices[foo_list.argmax()]
    indices.remove(ind1)
    time_series[ind1]=0
    foo_list=time_series[indices]
    #foo_list.remove(time_series[ind1])
    ind2=indices[foo_list.argmax()]
    
    if ind1<ind2:
        return [ind1,ind2]
    else:
        return [ind2,ind1]

np.unique(peak2,return_counts=True)

np.unique(peak1,return_counts=True)

## this one returns nice values at least for most of the districts even with order =40 and no other complexity


peak1=[]
peak2=[]
# basically order three can insure at least 2 peaks and I have to pick 2 from them only max ones I guess
# month ID automatically becomes ''indices+1''
# I just can only try order 3,4(maybe 5) ::: it does not work and specially won't in case of weeks

# although it is not a good solution as it is not applicable to weeks 
# it is possible to choose more than three and then work out from there
for i in range(len(district_ids_from_cases)):
    time_series=np.array(week_df[week_df['districtid']==district_ids_from_cases[i]].cases)
    indices=signal.argrelextrema(time_series,np.greater_equal, order=40)[0]
    if len(indices)==2:
        peak1.append(indices[0]+1)
        peak2.append(indices[1]+1)
    else:
        if len(indices)<2:
            indices=signal.argrelextrema(time_series,np.greater_equal, order=30)[0]
            if len(indices)==2:
                peak1.append(indices[0]+1)
                peak2.append(indices[1]+1)
            else:
                if len(indices)<2:
                    indices=signal.argrelextrema(time_series,np.greater_equal, order=20)[0]
                    if len(indices)==2:
                        peak1.append(indices[0]+1)
                        peak2.append(indices[1]+1)
                    else:
                        indices=choose_function(time_series,indices)
                        peak1.append(indices[0]+1)
                        peak2.append(indices[1]+1)
                else:
                    indices=choose_function(time_series,indices)
                    peak1.append(indices[0]+1)
                    peak2.append(indices[1]+1)
        else:
            indices=choose_function(time_series,indices)
            peak1.append(indices[0]+1)
            peak2.append(indices[1]+1)

# 585 cases pass len==2 condition at fiirst go

peak2.index(2)

data_csv[data_csv['District']=='churachandpur'].Confirmed.sum()

district_ids_from_cases[peak1.index(124)]

### test for any district  and also plot peaks
df=week_df[week_df['districtid']==district_ids_from_cases[peak1.index(124)]]
time_series=np.array(df.cases)

indices=signal.argrelextrema(time_series,np.greater_equal, order=20)[0]
print(indices)

# basically order three can insure at least 2 peaks and I have to pick 2 from them only max ones I guess
# month ID automatically becomes ''indices+1''
# I just can only try order 3,4(maybe 5)
print(time_series[indices])
# max two can be dones using no. cases in time series
df.cases.plot(figsize=(20,8), alpha=.3)
df.iloc[indices].cases.plot(style='.', lw=10, color='green', marker="^");
#df.iloc[ilocs_min].cases.plot(style='.', lw=10, color='green', marker="^");

### test for any district  and also plot peaks
df=week_df[week_df['districtid']==district_ids_from_cases[1]]
time_series=np.array(df.cases)

indices=signal.argrelextrema(time_series,np.greater_equal, order=20)[0]
print(indices)

# basically order three can insure at least 2 peaks and I have to pick 2 from them only max ones I guess
# month ID automatically becomes ''indices+1''
# I just can only try order 3,4(maybe 5)
print(time_series[indices])
# max two can be dones using no. cases in time series
df.cases.plot(figsize=(20,8), alpha=.3)
df.iloc[indices].cases.plot(style='.', lw=10, color='green', marker="^");
#df.iloc[ilocs_min].cases.plot(style='.', lw=10, color='green', marker="^");

### test for any district  and also plot peaks
df=month_df[month_df['districtid']==district_ids_from_cases[1]]
time_series=np.array(df.cases)

indices=signal.argrelextrema(time_series,np.greater_equal, order=3)[0]
print(indices)

# basically order three can insure at least 2 peaks and I have to pick 2 from them only max ones I guess
# month ID automatically becomes ''indices+1''
# I just can only try order 3,4(maybe 5)
print(time_series[indices])
# max two can be dones using no. cases in time series
df.cases.plot(figsize=(20,8), alpha=.3)
df.iloc[indices].cases.plot(style='.', lw=10, color='green', marker="^");
#df.iloc[ilocs_min].cases.plot(style='.', lw=10, color='green', marker="^");

peak1=[]
peak2=[]
# basically order three can insure at least 2 peaks and I have to pick 2 from them only max ones I guess
# month ID automatically becomes ''indices+1''
# I just can only try order 3,4(maybe 5) ::: it does not work and specially won't in case of weeks

# although it is not a good solution as it is not applicable to weeks 
# it is possible to choose more than three and then work out from there
for i in range(len(district_ids_from_cases)):
    time_series=np.array(month_df[month_df['districtid']==district_ids_from_cases[i]].cases)
    indices=signal.argrelextrema(time_series,np.greater_equal, order=4)[0]
    if len(indices)==2:
        peak1.append(indices[0]+1)
        peak2.append(indices[1]+1)
    else:
        if len(indices)<2:
            indices=signal.argrelextrema(time_series,np.greater_equal, order=3)[0]
            if len(indices)==2:
                peak1.append(indices[0]+1)
                peak2.append(indices[1]+1)
            else:
                if len(indices)<2:
                    indices=signal.argrelextrema(time_series,np.greater_equal, order=2)[0]
                    if len(indices)==2:
                        peak1.append(indices[0]+1)
                        peak2.append(indices[1]+1)
                    else:
                        indices=choose_function(time_series,indices)
                        peak1.append(indices[0]+1)
                        peak2.append(indices[1]+1)
                else:
                    indices=choose_function(time_series,indices)
                    peak1.append(indices[0]+1)
                    peak2.append(indices[1]+1)
        else:
            indices=choose_function(time_series,indices)
            peak1.append(indices[0]+1)
            peak2.append(indices[1]+1)

# 585 cases pass len==2 condition at fiirst go